{% extends 'student/studentbase.html' with hide_sidebar=True %}
{% block content %}
{%load static%}

<head>
  <link href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css" rel="stylesheet" id="bootstrap-css">
  <script src="//netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>
  <script src="//code.jquery.com/jquery-1.11.1.min.js"></script>
  <style>
    .question-container {
      display: none;
      padding: 20px;
      background-color: #f9f9f9;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    
    .active-question {
      display: block;
    }
    
    .timer-container {
      background-color: #f0f8ff;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      text-align: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    
    .timer-warning {
      color: #ff0000;
      animation: blink 1s infinite;
    }
    
    @keyframes blink {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    
    .progress-indicator {
      margin: 20px 0;
    }
    
    .progress-text {
      text-align: center;
      margin-bottom: 10px;
      font-weight: bold;
    }
    
    .navigation-buttons {
      display: flex;
      justify-content: space-between;
      margin-top: 20px;
    }
    
    /* Disable text selection */
    body.secure-exam {
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    /* Sticky footer with finish button */
    .exam-footer {
      position: fixed;
      bottom: 0;
      right: 0;
      left: 0;
      padding: 10px 20px;
      background-color: rgba(255, 255, 255, 0.9);
      box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
      text-align: right;
      z-index: 100;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .finish-exam-btn {
      background-color: #dc3545;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      font-weight: bold;
      transition: background-color 0.2s;
    }

    .finish-exam-btn:hover {
      background-color: #c82333;
    }

    .exam-progress-status {
      font-weight: 500;
    }
  </style>
</head>

<div class="jumbotron my-4">
  <div class="timer-container">
    <h3>Time Remaining</h3>
    <div id="exam-timer" class="h2">Loading...</div>
    <div id="question-timer-container">
      <h4>Current Question Time</h4>
      <div id="question-timer" class="h3">Loading...</div>
    </div>
  </div>

  <div class="progress-indicator">
    <div class="progress-text">
      Question <span id="current-question-num">1</span> of <span id="total-questions">{{ questions|length }}</span>
    </div>
    <div class="progress">
      <div id="progress-bar" class="progress-bar" role="progressbar" style="width: 0%"></div>
    </div>
  </div>

  <form id="exam-form" class="form" autocomplete="off" method="POST">
    {% csrf_token %}
    <h1 style="text-align: center;">{{course.course_name}}</h1>
    
    {% for q in questions %}
    <div class="question-container {% if forloop.first %}active-question{% endif %}" 
         id="question-{{q.id}}" 
         data-question-id="{{q.id}}" 
         data-question-index="{{forloop.counter0}}">
         
      <h3 class="text-info">{{ forloop.counter }}. {{q.question}}</h3>
      <h4 style="text-align: right;">[Marks {{q.marks}}]</h4>
      
      <div class="form-check mx-4">
        <input class="form-check-input question-option" type="radio" 
              name="question_{{q.id}}" 
              id="option1-{{q.id}}" 
              value="Option1"
              data-question-id="{{q.id}}"
              onclick="handleOptionSelect(this)">
        <label class="form-check-label" for="option1-{{q.id}}">
          {{q.option1}}
        </label>
      </div>

      <div class="form-check mx-4">
        <input class="form-check-input question-option" type="radio" 
              name="question_{{q.id}}" 
              id="option2-{{q.id}}" 
              value="Option2"
              data-question-id="{{q.id}}"
              onclick="handleOptionSelect(this)">
        <label class="form-check-label" for="option2-{{q.id}}">
          {{q.option2}}
        </label>
      </div>

      <div class="form-check mx-4">
        <input class="form-check-input question-option" type="radio" 
              name="question_{{q.id}}" 
              id="option3-{{q.id}}" 
              value="Option3"
              data-question-id="{{q.id}}"
              onclick="handleOptionSelect(this)">
        <label class="form-check-label" for="option3-{{q.id}}">
          {{q.option3}}
        </label>
      </div>

      <div class="form-check mx-4">
        <input class="form-check-input question-option" type="radio" 
              name="question_{{q.id}}" 
              id="option4-{{q.id}}" 
              value="Option4"
              data-question-id="{{q.id}}"
              onclick="handleOptionSelect(this)">
        <label class="form-check-label" for="option4-{{q.id}}">
          {{q.option4}}
        </label>
      </div>

      <div class="navigation-buttons">
        {% if course.allow_backtracking %}
        <button type="button" class="btn btn-secondary btn-prev" onclick="prevQuestion()" {% if forloop.first %}disabled{% endif %}>Previous</button>
        {% else %}
        <div></div> <!-- Empty div to maintain flex spacing -->
        {% endif %}
        
        {% if forloop.last %}
        <button type="button" class="btn btn-success btn-next" onclick="finishExam()">Finish Exam</button>
        {% else %}
        <button type="button" class="btn btn-primary btn-next" onclick="nextQuestion()">Next Question</button>
        {% endif %}
      </div>
    </div>
    {% endfor %}
  </form>
  
  <!-- Sticky Footer with Finish Button -->
  <div class="exam-footer">
    <div class="exam-progress-status">
      <span id="answered-count">0</span>/<span>{{ questions|length }}</span> questions answered
    </div>
    <button type="button" class="finish-exam-btn" onclick="finishExam()">
      <i class="fas fa-check-circle"></i> Finish Exam
    </button>
  </div>

  <div id="finish-confirmation" class="modal fade" tabindex="-1" role="dialog">
    <div class="modal-dialog" role="document">
      <div class="modal-content">
        <div class="modal-header">
          <h4 class="modal-title">Finish Exam?</h4>
          <button type="button" class="close" data-dismiss="modal" aria-label="Close">
            <span aria-hidden="true">&times;</span>
          </button>
        </div>
        <div class="modal-body">
          <p>Are you sure you want to finish and submit this exam?</p>
          <p>Unanswered questions will be marked as incorrect.</p>
          <p id="unanswered-warning" class="text-danger"></p>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-dismiss="modal">Cancel</button>
          <button type="button" class="btn btn-primary" onclick="submitExam()">Submit Exam</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  // Exam configuration
  const totalQuestions = {{ questions|length }};
  const totalExamTime = {{ course.total_time_minutes }} * 60; // Convert minutes to seconds
  const timePerQuestion = Math.floor(totalExamTime / totalQuestions);
  const securityLevel = "{{ course.security_level }}";
  const allowBacktracking = {% if course.allow_backtracking %}true{% else %}false{% endif %};
  
  // Variables for tracking the exam state
  let currentQuestionIndex = 0;
  let examTimeRemaining = totalExamTime;
  let questionTimeRemaining = timePerQuestion;
  let examTimerInterval;
  let questionTimerInterval;
  let answers = {};
  let questionTimings = {};
  let examStartTime = Date.now();
  
  // Initialize the exam
  document.addEventListener("DOMContentLoaded", function() {
    applySecurity();
    startExamTimer();
    startQuestionTimer();
    updateProgressBar();
    
    // Initialize the question timings
    const questions = document.querySelectorAll('.question-container');
    questions.forEach(question => {
      const questionId = question.dataset.questionId;
      questionTimings[questionId] = {
        startTime: null,
        totalTime: 0,
        endTime: null
      };
    });
    
    // Set start time for the first question
    if (questions.length > 0) {
      const firstQuestionId = questions[0].dataset.questionId;
      questionTimings[firstQuestionId].startTime = Date.now();
    }
    
    // Check for previously answered questions from cookies
    loadSavedAnswers();
    updateAnsweredCount();
  });
  
  // Apply security measures based on the security level
  function applySecurity() {
    if (securityLevel === 'low') {
      // Basic protection - already applied via CSS
    } 
    else if (securityLevel === 'medium' || securityLevel === 'high') {
      // Prevent right-click
      document.addEventListener("contextmenu", event => event.preventDefault());
      
      // Add class to disable text selection
      document.body.classList.add('secure-exam');
      
      if (securityLevel === 'high') {
        // Prevent keyboard shortcuts that might open developer tools
        document.addEventListener("keydown", function(event) {
          const key = event.key.toLowerCase();
          // Prevent F12, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+U
          if (
            event.keyCode === 123 || // F12
            (event.ctrlKey && event.shiftKey && (key === 'i' || key === 'j')) || // Ctrl+Shift+I or J
            (event.ctrlKey && key === 'u') // Ctrl+U
          ) {
            event.preventDefault();
            return false;
          }
        });
        
        // Detect when the window loses focus (might be switching to dev tools)
        window.addEventListener('blur', function() {
          document.getElementById('exam-timer').innerHTML += '<br><small class="text-danger">Warning: Exam window lost focus!</small>';
        });
      }
    }
  }
  
  // Start the overall exam timer
  function startExamTimer() {
    updateExamTimerDisplay();
    
    examTimerInterval = setInterval(function() {
      examTimeRemaining--;
      updateExamTimerDisplay();
      
      if (examTimeRemaining <= 0) {
        clearInterval(examTimerInterval);
        autoSubmitExam();
      }
    }, 1000);
  }
  
  // Update the exam timer display
  function updateExamTimerDisplay() {
    const minutes = Math.floor(examTimeRemaining / 60);
    const seconds = examTimeRemaining % 60;
    const timerElement = document.getElementById('exam-timer');
    
    timerElement.textContent = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
    
    // Add warning class if less than 10% of time remaining
    if (examTimeRemaining < totalExamTime * 0.1) {
      timerElement.classList.add('timer-warning');
    }
  }
  
  // Start the question timer
  function startQuestionTimer() {
    updateQuestionTimerDisplay();
    
    questionTimerInterval = setInterval(function() {
      questionTimeRemaining--;
      updateQuestionTimerDisplay();
      
      if (questionTimeRemaining <= 0) {
        clearInterval(questionTimerInterval);
        handleQuestionTimeout();
      }
    }, 1000);
  }
  
  // Update the question timer display
  function updateQuestionTimerDisplay() {
    const minutes = Math.floor(questionTimeRemaining / 60);
    const seconds = questionTimeRemaining % 60;
    const timerElement = document.getElementById('question-timer');
    
    timerElement.textContent = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
    
    // Add warning class if less than 10 seconds remaining
    if (questionTimeRemaining <= 10) {
      timerElement.classList.add('timer-warning');
    } else {
      timerElement.classList.remove('timer-warning');
    }
  }
  
  // Handle a question timeout
  function handleQuestionTimeout() {
    // Record timing data for the current question
    const currentQuestion = document.querySelector('.question-container.active-question');
    const questionId = currentQuestion.dataset.questionId;
    
    questionTimings[questionId].endTime = Date.now();
    questionTimings[questionId].totalTime = timePerQuestion;
    
    // Move to the next question automatically
    if (currentQuestionIndex < totalQuestions - 1) {
      nextQuestion();
    } else {
      finishExam();
    }
  }
  
  // Move to the next question
  function nextQuestion() {
    // Save the current question's state
    const currentQuestion = document.querySelector('.question-container.active-question');
    const questionId = currentQuestion.dataset.questionId;
    
    // Record timing data
    questionTimings[questionId].endTime = Date.now();
    questionTimings[questionId].totalTime = timePerQuestion - questionTimeRemaining;
    
    // Hide current question
    currentQuestion.classList.remove('active-question');
    
    // Move to the next question
    currentQuestionIndex++;
    
    // Show the next question
    const nextQuestionElement = document.querySelector(`.question-container[data-question-index="${currentQuestionIndex}"]`);
    nextQuestionElement.classList.add('active-question');
    
    // Update current question number display
    document.getElementById('current-question-num').textContent = currentQuestionIndex + 1;
    
    // Reset and start the question timer
    questionTimeRemaining = timePerQuestion;
    clearInterval(questionTimerInterval);
    startQuestionTimer();
    
    // Start timing for this question
    const nextQuestionId = nextQuestionElement.dataset.questionId;
    questionTimings[nextQuestionId].startTime = Date.now();
    
    // Update progress bar
    updateProgressBar();
    
    // Disable the previous button on the first question
    if (allowBacktracking) {
      const prevButtons = document.querySelectorAll('.btn-prev');
      prevButtons.forEach(button => button.disabled = (currentQuestionIndex === 0));
    }
  }
  
  // Move to the previous question (if allowed)
  function prevQuestion() {
    if (!allowBacktracking || currentQuestionIndex === 0) return;
    
    // Save the current question's state
    const currentQuestion = document.querySelector('.question-container.active-question');
    const questionId = currentQuestion.dataset.questionId;
    
    // Record timing data
    questionTimings[questionId].endTime = Date.now();
    questionTimings[questionId].totalTime += timePerQuestion - questionTimeRemaining;
    
    // Hide current question
    currentQuestion.classList.remove('active-question');
    
    // Move to the previous question
    currentQuestionIndex--;
    
    // Show the previous question
    const prevQuestionElement = document.querySelector(`.question-container[data-question-index="${currentQuestionIndex}"]`);
    prevQuestionElement.classList.add('active-question');
    
    // Update current question number display
    document.getElementById('current-question-num').textContent = currentQuestionIndex + 1;
    
    // Reset and start the question timer
    questionTimeRemaining = timePerQuestion;
    clearInterval(questionTimerInterval);
    startQuestionTimer();
    
    // Continue timing for this question
    const prevQuestionId = prevQuestionElement.dataset.questionId;
    questionTimings[prevQuestionId].startTime = Date.now();
    
    // Update progress bar
    updateProgressBar();
    
    // Disable the previous button on the first question
    if (allowBacktracking) {
      const prevButtons = document.querySelectorAll('.btn-prev');
      prevButtons.forEach(button => button.disabled = (currentQuestionIndex === 0));
    }
  }
  
  // Handle option selection
  function handleOptionSelect(element) {
    const questionId = element.dataset.questionId;
    const value = element.value;
    
    // Store the selected answer
    answers[questionId] = value;
    
    // Save to cookie for backup
    setCookie(`question_${questionId}`, value, 1);
    
    // Update answered questions count
    updateAnsweredCount();
  }
  
  // Update the count of answered questions
  function updateAnsweredCount() {
    const answeredCount = Object.keys(answers).length;
    document.getElementById('answered-count').textContent = answeredCount;
  }
  
  // Update the progress bar
  function updateProgressBar() {
    const progressPercent = ((currentQuestionIndex + 1) / totalQuestions) * 100;
    document.getElementById('progress-bar').style.width = `${progressPercent}%`;
  }
  
  // Show the finish confirmation modal
  function finishExam() {
    // Get total questions and count answered questions
    const totalQuestions = document.querySelectorAll('.question-container').length;
    const answeredQuestions = Object.keys(answers).length;
    const unansweredCount = totalQuestions - answeredQuestions;
    
    if (unansweredCount > 0) {
      // Create warning message
      let warningMessage = `Warning: You have ${unansweredCount} unanswered question`;
      if (unansweredCount > 1) warningMessage += 's';
      warningMessage += `. Unanswered questions will be marked as incorrect.`;
      
      // Set the warning message in the modal
      document.getElementById('unanswered-warning').textContent = warningMessage;
      
      // Show the warning in the modal
      document.getElementById('unanswered-warning').style.display = 'block';
    } else {
      // Hide the warning if all questions are answered
      document.getElementById('unanswered-warning').style.display = 'none';
    }
    
    // Show the finish confirmation modal
    new bootstrap.Modal(document.getElementById('finish-confirmation')).show();
  }
  
  // Submit the exam
  function submitExam() {
    // Stop the timers
    clearInterval(examTimerInterval);
    clearInterval(questionTimerInterval);
    
    // Save the current question's state
    const currentQuestion = document.querySelector('.question-container.active-question');
    if (currentQuestion) {
      const questionId = currentQuestion.dataset.questionId;
      questionTimings[questionId].endTime = Date.now();
      questionTimings[questionId].totalTime += timePerQuestion - questionTimeRemaining;
    }
    
    // Calculate the total time taken
    const totalTimeTaken = totalExamTime - examTimeRemaining;
    
    // Save all timing data
    for (const questionId in questionTimings) {
      // Skip if no start time (question was never shown)
      if (!questionTimings[questionId].startTime) continue;
      
      // For questions without an endTime (never completed), set the end time now
      if (!questionTimings[questionId].endTime) {
        questionTimings[questionId].endTime = Date.now();
        questionTimings[questionId].totalTime = Math.min(
          Math.floor((questionTimings[questionId].endTime - questionTimings[questionId].startTime) / 1000),
          timePerQuestion
        );
      }
      
      // Save to cookies
      setCookie(`q_${questionId}_final_time`, questionTimings[questionId].totalTime, 1);
    }
    
    // Save the total exam time
    setCookie("exam_total_time", totalTimeTaken, 1);
    
    // Save all answers to cookies for the calculate-marks endpoint
    const questions = document.querySelectorAll('.question-container');
    questions.forEach((question, index) => {
      const questionId = question.dataset.questionId;
      const answer = answers[questionId];
      
      if (answer) {
        setCookie(index + 1, answer, 1); // Legacy format for calculate-marks
      }
    });
    
    // Redirect to calculate-marks
    window.location.href = '/student/calculate-marks';
  }
  
  // Auto-submit the exam when the total time expires
  function autoSubmitExam() {
    alert("Time's up! Your exam will be submitted automatically.");
    submitExam();
  }
  
  // Set a cookie
  function setCookie(cname, cvalue, exdays) {
    const d = new Date();
    d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
    const expires = "expires=" + d.toUTCString();
    document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
  }
  
  // Load any previously saved answers from cookies
  function loadSavedAnswers() {
    const questions = document.querySelectorAll('.question-container');
    questions.forEach(question => {
      const questionId = question.dataset.questionId;
      const savedAnswer = getCookie(`question_${questionId}`);
      
      if (savedAnswer) {
        // Mark as answered in our tracking
        answers[questionId] = savedAnswer;
        
        // Select the correct radio button
        const radioInput = document.querySelector(`input[name="question_${questionId}"][value="${savedAnswer}"]`);
        if (radioInput) {
          radioInput.checked = true;
        }
      }
    });
  }
  
  // Get cookie value
  function getCookie(name) {
    const value = `; ${document.cookie}`;
    const parts = value.split(`; ${name}=`);
    if (parts.length === 2) return parts.pop().split(';').shift();
    return null;
  }
</script>

<br><br><br><br><br><br>
{% endblock content %} 